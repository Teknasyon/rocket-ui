{"version":3,"file":"Tooltip.stories.8cd54a56.js","sources":["../../node_modules/@floating-ui/core/dist/floating-ui.core.esm.js","../../node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js","../../src/components/Tooltip/common.ts","../../src/components/Tooltip/Tooltip.vue","../../src/directives/index.ts","../../src/components/Tooltip/Tooltip.stories.mdx"],"sourcesContent":["function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (validMiddleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement` middleware', 'detected. This will lead to an infinite loop. Ensure only one of', 'either has been passed to the `middleware` array.'].join(' '));\n    }\n\n    if (!reference || !floating) {\n      console.error(['Floating UI: The reference and/or floating element was not defined', 'when `computePosition()` was called. Ensure that both elements have', 'been created and can be measured.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (resetCount > 50) {\n        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n      }\n    }\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const alignment = getAlignment(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max); // Make sure that arrow points at the reference\n\n    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];\n    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset(middlewareArguments) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      await apply({ ...middlewareArguments,\n        ...dimensions\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n\n      if (rects.floating.width !== nextDimensions.width || rects.floating.height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element);\n  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter; // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some( // TS 4.1 compat\n  value => {\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  const result = // Step into the shadow DOM of the parent of a slotted node\n  node.assignedSlot || // DOM Element detected\n  node.parentNode || ( // ShadowRoot detected\n  isShadowRoot(node) ? node.host : null) || // Fallback\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  if (clippingAncestor === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingAncestor)) {\n    return getInnerBoundingClientRect(clippingAncestor, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingElementAncestors(element) {\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element; // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const containingBlock = isContainingBlock(currentNode);\n    const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);\n\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n\n    currentNode = getParentNode(currentNode);\n  }\n\n  return result;\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n\n  async getElementRects(_ref) {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(floating))\n      }\n    };\n  },\n\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n\n    if (!isElement(reference) && reference.contextElement && !animationFrame) {\n      observer.observe(reference.contextElement);\n    }\n\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return () => {\n    var _observer;\n\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { autoUpdate, computePosition, getOverflowAncestors, platform };\n","import {\n  computePosition,\n  flip,\n  shift,\n  offset,\n  arrow,\n  hide,\n} from '@floating-ui/dom';\nimport type { Ref } from 'vue';\n\nexport function update(\n  { value: trigger }: Ref<HTMLDivElement>,\n  { value: tooltip }: Ref<HTMLDivElement>,\n  { value: arrowElement }: Ref<HTMLDivElement>,\n  placement: Placements,\n  offsetParam: number,\n  padding: number\n) {\n  if (!trigger || !tooltip) return;\n  computePosition(trigger, tooltip, {\n    placement,\n    middleware: [\n      offset(offsetParam),\n      shift({ padding }),\n      arrow({ element: arrowElement }),\n      flip(),\n      hide(),\n    ],\n  }).then(({ x, y, placement, middlewareData }) => {\n    Object.assign(tooltip.style, {\n      left: `${x}px`,\n      top: `${y}px`,\n    });\n\n    if (arrowElement && middlewareData.arrow) {\n      const { x: arrowX, y: arrowY } = middlewareData.arrow;\n\n      const staticSide = {\n        top: Placement.Bottom,\n        right: Placement.Left,\n        bottom: Placement.Top,\n        left: Placement.Right,\n      }[placement.split('-')[0]];\n\n      Object.assign(arrowElement.style, {\n        left: x != null ? `${arrowX}px` : '',\n        top: y != null ? `${arrowY}px` : '',\n        right: '',\n        bottom: '',\n        [`${staticSide}`]: '-4px',\n      });\n    }\n  });\n}\n\nexport type Placements =\n  | 'top'\n  | 'bottom'\n  | 'left'\n  | 'right'\n  | 'top-start'\n  | 'top-end'\n  | 'right-start'\n  | 'right-end'\n  | 'bottom-start'\n  | 'bottom-end'\n  | 'left-start'\n  | 'left-end';\n\nexport enum Placement {\n  Top = 'top',\n  Bottom = 'bottom',\n  Left = 'left',\n  Right = 'right',\n  TopStart = 'top-start',\n  TopEnd = 'top-end',\n  RightStart = 'right-start',\n  RightEnd = 'right-end',\n  BottomStart = 'bottom-start',\n  BottomEnd = 'bottom-end',\n  LeftStart = 'left-start',\n  LeftEnd = 'left-end',\n}\n\nexport type Triggers = 'click' | 'hover' | 'manual';\n\nexport enum Trigger {\n  Click = 'click',\n  Hover = 'hover',\n  Manual = 'manual',\n}\n","<script setup lang=\"ts\">\nimport './tooltip.css';\nimport {\n  type Placements,\n  type Triggers,\n  Placement,\n  update,\n  Trigger,\n} from './common';\nimport { computed, ref, watchEffect } from 'vue';\n\nexport interface IProps {\n  /**\n   * Placement of the tooltip\n   * @type Placements\n   * @default Placement.Top\n   * @example\n   * <Tooltip placement=\"top\" />\n   */\n  placement?: Placements;\n\n  /**\n   * Text of the tooltip content\n   * @type string\n   * @default ''\n   * @example\n   * <Tooltip text=\"Tooltip\" />\n   */\n  text?: string;\n\n  /**\n   * Dark theme of the tooltip deneme 1 2 3\n   * @type boolean\n   * @default true\n   * @example\n   * <Tooltip dark />\n   */\n  dark?: boolean;\n\n  /**\n   * Light theme of the tooltip\n   * @type boolean\n   * @default false\n   * @example\n   * <Tooltip light />\n   */\n  light?: boolean;\n\n  /**\n   * Triggers of the tooltip\n   * @type Triggers\n   * @default Trigger.Hover\n   * @example\n   * <Tooltip triggers=\"hover\" />\n   */\n  triggers?: Triggers;\n\n  /**\n   * Auto hide of the tooltip\n   * @type boolean\n   * @default true\n   * @example\n   * <Tooltip autoHide />\n   */\n  autoHide?: boolean;\n\n  /**\n   * Hide delay of the tooltip\n   * @type number\n   * @default 3000\n   * @example\n   * <Tooltip hideDelay={3000} />\n   */\n  hideDelay?: number;\n\n  /**\n   * Show delay of the tooltip\n   * @type number\n   * @default 0\n   * @example\n   * <Tooltip showDelay={0} />\n   */\n  showDelay?: number;\n\n  /**\n   * Shown state of the tooltip\n   * @type boolean\n   * @default false\n   * @example\n   * <Tooltip shown />\n   */\n  shown?: boolean;\n\n  /**\n   * Disabled state of the tooltip\n   * @type boolean\n   * @default false\n   * @example\n   * <Tooltip disabled />\n   */\n  disabled?: boolean;\n\n  /**\n   * Offset of the tooltip\n   * @type number\n   * @default 0\n   * @example\n   * <Tooltip offset={0} />\n   * @link https://floating-ui.com/docs/tutorial#offset-middleware\n   */\n  offset?: number;\n\n  /**\n   * Padding of the tooltip\n   * @type number\n   * @default 2\n   * @example\n   * <Tooltip padding={0} />\n   * @link https://floating-ui.com/docs/tutorial#shift-middleware\n   */\n  padding?: number;\n\n  /**\n   * Outside click of the tooltip\n   * @type boolean\n   * @default false\n   * @example\n   * <Tooltip outsideClick />\n   */\n  outsideClick?: boolean;\n\n  /**\n   * Trigger content of the tooltip\n   * @type string\n   * @default ''\n   * @example\n   * <Tooltip triggerContent=\"Trigger\" />\n   */\n  triggerContent?: string;\n\n  /**\n   * Resizable of the tooltip\n   * @type boolean\n   * @default true\n   * @example\n   * <Tooltip resizable />\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/resize_event\n   */\n  resizable?: boolean;\n}\nconst props = withDefaults(defineProps<IProps>(), {\n  placement: Placement.Top,\n  text: '',\n  dark: true,\n  light: false,\n  triggers: Trigger.Hover,\n  autoHide: true,\n  hideDelay: 3000,\n  showDelay: 0,\n  shown: false,\n  disabled: false,\n  offset: 0,\n  padding: 2,\n  outsideClick: false,\n  triggerContent: '',\n  resizable: true,\n});\nconst emit = defineEmits(['show', 'hide']);\n\n// @ts-ignore\nconst trigger = ref<HTMLDivElement>(null);\n// @ts-ignore\nconst tooltip = ref<HTMLDivElement>(null);\n// @ts-ignore\nconst arrowElement = ref<HTMLDivElement>(null);\n\nfunction showTooltip() {\n  const { placement, offset, padding, disabled } = props;\n  if (disabled) return;\n  tooltip.value.style.display = 'block';\n  emit('show');\n  update(trigger, tooltip, arrowElement, placement, offset, padding);\n  handleAutoHide();\n  if (props.outsideClick) toggleOutsideClick('add');\n}\n\nfunction hideTooltip() {\n  tooltip.value.style.display = '';\n  emit('hide');\n  if (props.outsideClick) toggleOutsideClick('remove');\n}\n\nconst handleAutoHide = () => {\n  if (props.autoHide) {\n    setTimeout(() => {\n      hideTooltip();\n    }, props.hideDelay);\n  }\n};\n\nconst toggleOutsideClick = (toggle: string) => {\n  if (toggle === 'add') document.addEventListener('click', hideTooltip);\n\n  if (toggle === 'remove') document.removeEventListener('click', hideTooltip);\n};\n\nconst onClick = () => {\n  if (props.disabled) return;\n  if (props.triggers == Trigger.Click) {\n    if (tooltip.value.style.display === 'block') hideTooltip();\n    else showTooltip();\n  }\n};\n\nconst onMouseEnter = () => {\n  if (props.disabled) return;\n  if (props.triggers === Trigger.Hover) showTooltip();\n};\n\nconst onMouseLeave = () => {\n  if (props.disabled) return;\n  if (tooltip.value.style.display === '' && props.triggers === Trigger.Hover) {\n    showTooltip();\n    return;\n  } else if (\n    tooltip.value.style.display !== '' &&\n    props.triggers === Trigger.Hover\n  ) {\n    hideTooltip();\n  }\n};\n\nconst onMouseMove = () => {\n  const { placement, offset, padding, disabled } = props;\n  if (disabled) return;\n  if (props.triggers === Trigger.Hover)\n    update(trigger, tooltip, arrowElement, placement, offset, padding);\n};\n\nconst classes = computed(() => {\n  return {\n    tooltip: true,\n    'tooltip--dark': props.dark,\n    'tooltip--light': props.light,\n  };\n});\n\n/**\n * Listen the resize event of window\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/resize_event\n */\nwindow.onresize = () => {\n  const { placement, offset, padding, disabled } = props;\n  if (disabled) return;\n  if (props.resizable)\n    update(trigger, tooltip, arrowElement, placement, offset, padding);\n};\n\nwatchEffect(\n  () => {\n    if (props.disabled) return;\n    if (props.shown && props.triggers === Trigger.Manual) showTooltip();\n  },\n  { flush: 'post' } // this is important to avoid infinite loop & for fire on mounted\n);\n\nconst animationDuration = computed(() => {\n  return `${props.showDelay}ms`;\n});\n</script>\n\n<template>\n  <div\n    ref=\"trigger\"\n    :aria-disabled=\"props.disabled\"\n    class=\"trigger\"\n    @click.stop=\"onClick\"\n    @mouseenter.stop=\"onMouseEnter\"\n    @mouseleave.stop=\"onMouseLeave\"\n    @mousemove.stop=\"onMouseMove\"\n  >\n    <slot name=\"trigger\" />\n\n    <div v-if=\"!$slots['trigger']\" v-html=\"props.triggerContent\" />\n  </div>\n  <div id=\"tooltip\" ref=\"tooltip\" :class=\"classes\" role=\"tooltip\">\n    <slot name=\"content\" />\n    <div\n      v-if=\"!$slots['content']\"\n      :class=\"{\n        tooltip__content: true,\n        'tooltip__content--dark': props.dark,\n        'tooltip__content--light': props.light,\n      }\"\n    >\n      {{ props.text }}\n    </div>\n    <div\n      v-if=\"!$slots['content']\"\n      id=\"arrow\"\n      ref=\"arrowElement\"\n      :class=\"{\n        tooltip__arrow: true,\n        'tooltip__arrow--dark': props.dark,\n        'tooltip__arrow--light': props.light,\n      }\"\n    />\n  </div>\n</template>\n<style scoped>\n.tooltip {\n  animation-name: tooltip-show;\n  animation-duration: v-bind('animationDuration');\n  animation-fill-mode: forwards;\n  animation-timing-function: ease-in-out;\n}\n@keyframes tooltip-show {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n</style>\n","import { type App, createApp, h, ref, type DirectiveBinding } from 'vue';\nimport Tooltip from '../components/Tooltip/Tooltip.vue';\n\nexport const vTooltip = {\n  mounted(el: HTMLElement, binding: DirectiveBinding) {\n    console.log('vTooltip');\n    const app: App = createApp({\n      setup() {\n        const props = ref(binding.value);\n\n        return () =>\n          h(Tooltip, {\n            ...props.value,\n          });\n      },\n    });\n    app.mount(el);\n  },\n};\n","import { Canvas, Meta, Story, ArgsTable } from '@storybook/addon-docs';\nimport { action } from '@storybook/addon-actions';\nimport Tooltip from './Tooltip.vue';\nimport Button from '../Button/Button.vue';\nimport Icon from '../Icon/Icon.vue';\nimport { vTooltip } from '../../directives';\n\nexport const Default = ({ buttonContent, ...args }) => {\n  return {\n    components: { Tooltip, Button },\n    setup() {\n      return {\n        args,\n        show: action('show'),\n        hide: action('hide'),\n      };\n    },\n    template: `\n    <Tooltip\n      v-bind=\"args\"\n      @show=\"show\"\n      @hide=\"hide\"\n    >\n      <template #trigger>\n        <Button variant=\"primary\">${buttonContent}</Button>\n      </template>\n    </Tooltip>\n    `,\n  };\n};\n\nexport const WithContentSlot = (args) => {\n  return {\n    components: { Tooltip, Icon },\n    setup() {\n      return {\n        args,\n        show: action('show'),\n        hide: action('hide'),\n      };\n    },\n    template: `\n    <Tooltip\n      v-bind=\"args\"\n      @show=\"show\"\n      @hide=\"hide\"\n    >\n      <template #trigger>\n        <Icon name=\"info\" />\n      </template>\n      <template #content>\n        <span style=\"background: red; color: #fff; padding: 8px;\">This is a tooltip</span>\n      </template>\n    </Tooltip>\n    `,\n  };\n};\n\nexport const ToggleTemplate = (args) => {\n  return {\n    components: { Tooltip },\n    setup() {\n      return {\n        args,\n        show: action('show'),\n        hide: action('hide'),\n      };\n    },\n    template: `\n    <Tooltip\n      v-bind=\"args\"\n      @show=\"show\"\n      @hide=\"hide\"\n    >\n      <template #trigger>\n        <span>Toggle tooltip</span>\n      </template>\n    </Tooltip>\n    `,\n  };\n};\n\nexport const WithDirectives = () => {\n  return {\n    components: { Button },\n    directives: { tooltip: vTooltip },\n    template: `\n    <Button \n      v-tooltip=\"{\n        triggerContent: '<div>Hello World!</div>',\n        text: 'Directive tooltip',\n        autoHide: false,\n        placement: 'right',\n        offset: 30,\n        }\" \n    >\n      This hidden\n    </Button>\n    `,\n  };\n};\n\nexport const defaultArgs = {\n  placement: {\n    control: {\n      type: 'select',\n      options: [\n        'top',\n        'right',\n        'bottom',\n        'left',\n        'top-start',\n        'top-end',\n        'right-start',\n        'right-end',\n        'bottom-start',\n        'bottom-end',\n        'left-start',\n        'left-end',\n      ],\n    },\n    defaultValue: 'top',\n  },\n  text: {\n    control: {\n      type: 'text',\n    },\n    defaultValue:\n      'Tooltips are used to describe or identify an element. In most scenarios, tooltips help the user understand the meaning, function or alt-text of an element.',\n  },\n  dark: {\n    control: {\n      type: 'boolean',\n    },\n    defaultValue: true,\n  },\n  light: {\n    control: {\n      type: 'boolean',\n    },\n    defaultValue: false,\n  },\n  triggers: {\n    control: {\n      type: 'select',\n      options: ['hover', 'click', 'manual'],\n    },\n    defaultValue: 'hover',\n  },\n  autoHide: {\n    control: {\n      type: 'boolean',\n    },\n    defaultValue: false,\n  },\n  hideDelay: {\n    control: {\n      type: 'number',\n    },\n    defaultValue: 3000,\n  },\n  showDelay: {\n    control: {\n      type: 'number',\n    },\n    defaultValue: 0,\n  },\n  shown: {\n    control: {\n      type: 'boolean',\n    },\n    defaultValue: false,\n  },\n  disabled: {\n    control: {\n      type: 'boolean',\n    },\n    defaultValue: false,\n  },\n  offset: {\n    control: {\n      type: 'range',\n    },\n    defaultValue: 12,\n  },\n  padding: {\n    control: {\n      type: 'range',\n    },\n    defaultValue: 0,\n  },\n  outsideClick: {\n    control: {\n      type: 'boolean',\n    },\n    defaultValue: false,\n  },\n  resizable: {\n    control: {\n      type: 'boolean',\n    },\n    defaultValue: false,\n  },\n};\n\n<Meta\n  title=\"Components/Tooltip\"\n  component={Tooltip}\n  argTypes={{ ...defaultArgs }}\n  parameters={{\n    viewMode: 'docs',\n  }}\n/>\n\n# Tooltip\n\nA tooltip is a small pop-up window that appears when the user hovers over an element. It can be used to provide additional information or context about the element.\n\n- [Overview](#overview)\n\n- [Usage with props](#usage)\n\n- [Playground](#playground)\n\n- [Stories](#stories)\n\n- [Tips](#tips)\n\n## Overview <a id=\"overview\" />\n\nThe tooltip component allows developers to easily add tooltips to their applications.\n\n<Canvas withSource=\"open\">\n  <Story\n    name=\"Overview\"\n    argTypes={{ ...Default.argTypes }}\n    args={{\n      buttonContent: 'Hover me',\n    }}\n  >\n    {Default.bind({})}\n  </Story>\n</Canvas>\n\n### Playground <a id=\"playground\" />\n\n> Changes you make in the controls will be reflected in the example above.\n\n<ArgsTable story=\"Overview\" exclude={/^(trigger|content|click|on.*)/} />\n\n## Stories <a id=\"stories\" />\n\n### Default\n\n<Canvas withSource=\"open\">\n  <Story\n    name=\"Default\"\n    argTypes={{ ...Default.argTypes }}\n    args={{\n      buttonContent: 'Hover me',\n    }}\n  >\n    {Default.bind({})}\n  </Story>\n</Canvas>\n\n### With Click Trigger\n\n<Canvas withSource=\"open\">\n  <Story\n    name=\"With Click Trigger\"\n    argTypes={{ ...ToggleTemplate.argTypes }}\n    args={{\n      triggers: 'click',\n      text: 'Clicked!',\n      outsideClick: true,\n    }}\n  >\n    {ToggleTemplate.bind({})}\n  </Story>\n</Canvas>\n\n### With Manual Trigger\n\n<Canvas withSource=\"open\">\n  <Story\n    name=\"With Manual Trigger\"\n    argTypes={{ ...Default.argTypes }}\n    args={{\n      triggers: 'manual',\n      dark: false,\n      light: true,\n      text: 'Manual!',\n      buttonContent: 'Toggle Shown',\n    }}\n  >\n    {Default.bind({})}\n  </Story>\n</Canvas>\n\n### With Content Slot\n\n<Canvas withSource=\"open\">\n  <Story\n    name=\"With Content Slot\"\n    argTypes={{ ...WithContentSlot.argTypes }}\n    args={{ text: '', triggers: 'hover' }}\n  >\n    {WithContentSlot.bind({})}\n  </Story>\n</Canvas>\n\n## With Directives\n\n<Canvas withSource=\"open\">\n  <Story\n    name=\"With directives\"\n    argTypes={{}}\n    parameters={{ controls: { disable: true } }}\n  >\n    {WithDirectives.bind({})}\n  </Story>\n</Canvas>\n\n## Usage with props <a id=\"usage\" />\n\n## placement (optional) and text (optional)\n\nIt supports various **placement** options such as top, right, bottom, and left, as well as more specific placements like top-start, top-end, right-start, right-end, bottom-start, bottom-end, left-start, and left-end. The **text** prop allows developers to specify the text that will be displayed in the tooltip.\n\n## light (optional) and dark (optional)\n\nThe **light** and **dark** props can be used to change the color scheme of the tooltip.\n\n## autoHide (optional) and hideDelay (optional)\n\nThe **autoHide** prop allows the tooltip to automatically hide after a specified delay, while the **hideDelay** and showDelay props can be used to control the delay before the tooltip is hidden or shown.\n\n## shown (optional) and disabled (optional)\n\nThe **shown** prop can be used to manually control the visibility of the tooltip, while the **disabled** prop can be used to disable the tooltip entirely.\n\n## offset (optional), padding (optional) and outsideClick (optional)\n\nThe **offset** and **padding** props can be used to adjust the position of the tooltip, and the **outsideClick** prop allows developers to specify whether the tooltip should be hidden when the user clicks outside of it.\n\n## resizable (optional)\n\nThe **resizable** prop can be used to specify whether the tooltip should be resizable.\n\n## Tips <a id=\"tips\" />\n\n💡 Tooltips are meant to provide additional information or context, so it's important to keep the text short and to the point. Avoid using long sentences or paragraphs of text, as it can make the tooltip difficult to read and may cause the user to lose interest.\n\n💡 The placement of the tooltip can greatly affect its effectiveness. Use clear and consistent placement across your application to make it easy for the user to understand where the tooltip will appear.\n\n💡 The delay before the tooltip appears and disappears can greatly affect the user's experience. Experiment with different values for the showDelay and hideDelay props to find the right balance between making the tooltip appear quickly enough to be useful but not so quickly that it becomes distracting.\n\n💡 Use the light and dark props to match the tooltip color scheme with the overall theme of your application. This will make the tooltip feel like a natural part of the interface.\n\n💡 The offset prop allows you to adjust the position of the tooltip relative to the trigger element. Use it to fine-tune the placement of the tooltip and make it feel more natural.\n\n💡 The padding prop can be used to add space around the tooltip text, which can make it easier to read.\n\n💡 This can improve the user experience by preventing the tooltip from staying visible when the user is no longer interacting with the trigger element.\n\n💡 Always test the tooltip with real users to see how it works in practice and to gather feedback on how it can be improved.\n"],"names":["getSide","placement","getAlignment","getMainAxisFromPlacement","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","commonY","mainAxis","length","commonAlign","side","isVertical","coords","computePosition","config","strategy","middleware","platform","validMiddleware","rects","x","y","statefulPlacement","middlewareData","resetCount","i","name","fn","nextX","nextY","data","reset","expandPaddingObject","padding","getSideObjectFromPadding","rectToClientRect","rect","detectOverflow","middlewareArguments","options","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","elementClientRect","min","max","within","min$1","value","max$1","arrow","alignment","arrowDimensions","minProp","maxProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","center","offset","alignmentOffset","hash$1","getOppositePlacement","matched","getAlignmentSides","mainAlignmentSide","hash","getOppositeAlignmentPlacement","sides","getExpandedPlacements","oppositePlacement","flip","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","flipAlignment","detectOverflowOptions","fallbackPlacements","placements","overflow","overflows","overflowsData","main","cross","_middlewareData$flip$","_middlewareData$flip2","nextIndex","nextPlacement","resetPlacement","_overflowsData$map$so","d","acc","a","b","getSideOffsets","isAnySideFullyClipped","hide","_temp","offsets","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","crossAxis","alignmentAxis","diffCoords","getCrossAxis","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","isWindow","getWindow","node","ownerDocument","getComputedStyle","getNodeName","getUAString","uaData","item","isHTMLElement","isElement","isNode","isShadowRoot","OwnElement","isOverflowElement","overflowX","overflowY","display","isTableElement","isContainingBlock","isFirefox","css","backdropFilter","contain","isLayoutViewport","isLastTraversableNode","round","getBoundingClientRect","includeScale","isFixedStrategy","_win$visualViewport$o","_win$visualViewport","_win$visualViewport$o2","_win$visualViewport2","clientRect","scaleX","scaleY","win","addVisualOffsets","width","height","getDocumentElement","getNodeScroll","getWindowScrollBarX","isScaled","getRectRelativeToOffsetParent","offsetParent","isOffsetParentAnElement","documentElement","scroll","offsetRect","getParentNode","result","getTrueOffsetParent","getContainingBlock","currentNode","getOffsetParent","window","getDimensions","convertOffsetParentRelativeRectToViewportRelativeRect","getViewportRect","html","visualViewport","layoutViewport","getDocumentRect","_element$ownerDocumen","body","getNearestOverflowAncestor","parentNode","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","target","updatedList","getInnerBoundingClientRect","top","left","getClientRectFromClippingAncestor","clippingAncestor","getClippingElementAncestors","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","containingBlock","ancestor","getClippingRect","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getOffsetParentFn","getDimensionsFn","computePosition$1","update","trigger","tooltip","arrowElement","offsetParam","arrowX","arrowY","staticSide","Placement","Trigger","ref","showTooltip","disabled","props","emit","handleAutoHide","toggleOutsideClick","hideTooltip","toggle","onClick","onMouseEnter","onMouseLeave","onMouseMove","classes","computed","watchEffect","animationDuration","vTooltip","binding","createApp","h","Tooltip","Default","buttonContent","args","components","Button","setup","show","action","template","WithContentSlot","Icon","ToggleTemplate","WithDirectives","directives","defaultArgs","control","type","defaultValue","text","dark","light","triggers","autoHide","hideDelay","showDelay","shown","outsideClick","resizable","layoutProps","MDXLayout","MDXContent","mdx","Meta","viewMode","Canvas","Story","argTypes","bind","ArgsTable","controls","disable","isMDXComponent","overview","storyName","parameters","storySource","source","defaultStory","withClickTrigger","withManualTrigger","withContentSlot","withDirectives","componentMeta","title","component","includeStories","mdxStoryNameToKey","docs","page","AddContext","__namedExportsOrder"],"mappings":"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"}